/* Source map.c */
#include "map.h"

const size_t MAP_DEFAULT_VECTOR_SIZE = 2048;

/**
 * @brief Static - Hash function
 *
 * Value returned from this function cannot be  used directly
 * as the index, but its modulus againt vector size can.
 * 
 * One-byte-at-a-time hash based on Murmur's mix
 * Source: https://github.com/aappleby/smhasher/blob/master/src/Hashes.cpp
 */
static uint32_t MurmurOAAT_32(const char* str, uint32_t h)
{
    for (; *str; ++str) {
        h ^= *str;
        h *= 0x5bd1e995;
        h ^= h >> 15;
    }
    return h;
}

/**
 * @brief Static - Convert key to index
 * 
 * Index is computed as the remainder of the hashing value
 * divided by vector size.
 * 
 * @param key_str : Key string to be projected into index
 *                  in the vector of the map.
 */
static size_t key_string_to_index(const char* key_str)
{
    size_t idx = MurmurOAAT_32(key_str, 1) % MAP_DEFAULT_VECTOR_SIZE;
    return idx;
}

/**
 * @brief Static - Make a pair
 * 
 * Returns a pointer of MapItem created on heap. Map item is
 * an intermediary that establishes connection between key
 * and value, it is thus only used by the map. The value is
 * a pointer to the data.
 * 
 * @note Resource allocated to store the key must be freed.
 */
static struct abel_key_value_pair* make_pair_ptr(char* key, void* ptr_data)
{
    struct abel_key_value_pair* ptr_pair = NULL;
    ptr_pair = malloc( sizeof(*ptr_pair) );
    ptr_pair->key = malloc(strlen(key) + 1);
    strcpy(ptr_pair->key, key);
    ptr_pair->ptr_data = ptr_data;
    return ptr_pair;
}

struct abel_return_option abel_free_pair(struct abel_key_value_pair* ptr_pair)
{
    struct abel_return_option ret;
    /* return the pointer to the data held by pair */
    ret.pointer = ptr_pair->ptr_data;
    free(ptr_pair->key);
    free(ptr_pair);
    return ret;
}

/**
 * @todo How to return errors?
 * 
 */
struct abel_map* abel_make_map_ptr()
{
    struct abel_map* ptr_map = NULL;
    ptr_map = malloc( sizeof(*ptr_map) );
    ptr_map->ptr_pair_vector = abel_make_vector_ptr(MAP_DEFAULT_VECTOR_SIZE);
    ptr_map->ptr_coll_vector = abel_make_vector_ptr(MAP_DEFAULT_VECTOR_SIZE);;
    ptr_map->size = 0;
    return ptr_map;
}

size_t abel_map_size(struct abel_map* ptr_map)
{
    return ptr_map->size;
}

/**
 * @brief Static - Resolve collision
 *
 * Collision resolution operates on the linked list created
 * for each key-converted index on the collision vector. It
 * is only called internally by `abel_map_insert` method.
 * 
 * @note
 *     1. Collision vector always stores the pointer to the
 *        head of the linked list. 
 * 
 * Only called internally by `abel_dict_insert` method. Argument
 * `index` must be generated by hashing function from the given
 * key string.
 * 
 * Caution
 * 
 * Always update the ref count before insertion or deletion.
 */
static struct abel_return_option resolve_collision(
    struct abel_map* ptr_map, struct abel_vector* ptr_coll_vector,
    size_t idx, char* key_str, void* ptr_data)
{
    struct abel_return_option ret;
    if (abel_vector_at(ptr_coll_vector, idx).pointer != NULL) {
    /*  Case 0: Collisions have already been registered,
        then search the linked list for the given key.
    */
        /* Get head of the linked list */
       struct abel_linked_list* ptr_current_node
           = abel_vector_at(ptr_coll_vector, idx).pointer;
        Bool key_found = false;               
        while (ptr_current_node != NULL) {
            struct abel_key_value_pair* ptr_current_pair = ptr_current_node->ptr_data;
            /* key found */
            if (strcmp(ptr_current_pair->key, key_str) == 0) {
                key_found = true;
                break;
            }
            ptr_current_node = ptr_current_node->next;
        }
        if (key_found == false) {
            /*  Key is not found and is thus new;
                append new pair to the linked list
            */
            struct abel_key_value_pair* ptr_new_pair = make_pair_ptr(key_str, ptr_data); 
            abel_linked_list_append(
                abel_vector_at(ptr_coll_vector, idx).pointer, ptr_new_pair);
            ptr_map->size++;    // increase map size
            ret = abel_option_okay(ptr_new_pair);
        } else {
            /* If key is found, return KEY_EXISTS error */
            ret = abel_option_error( error_key_exists() );
        }
    } else {
    /*  Case 1: No collision has been registered, then register it.
        Make a linked list node and store its address in collision
        vector; the node is pointing at the pair object.
    */
        struct abel_key_value_pair* ptr_new_pair = make_pair_ptr(key_str, ptr_data);
        abel_vector_emplace(ptr_coll_vector, idx,
                            abel_make_linked_list_node(ptr_new_pair) );
        ptr_map->size++;    // increase map size
        ret = abel_option_okay(ptr_new_pair);
    }
    return ret;
}

/**
 * @brief Static - Insert a pair into map
 * 
 * Performs the insertion. This function is invoked by
 * by public interface `abel_map_insert`.
 * 
 * @param ptr_map : Pointer to the target map
 * 
 * @param idx : Index on pair vector or collision vector.
 *              It must be converted from the `key_str` by
 *              a hashing function
 * @param key_str : Key in pair to be inserted into map
 * 
 * @param ptr_data : Pointer to the data to be associated
 *                   with the key, i.e the actual value the
 *                   pair is pointing at.
 * @return If the index has been occupied, there are further
 *         2 scenarios: (1) If given key is identical to the
 *         key of the current occupant, report KEY_EXISTS error.
 *         (2) If not, this is collision and we must resolve it.
 *         Should the key-value pair is inserted successfully,
 *         a pointer to the pair is returned.
 * @note 
 *     1. Called internally by public method `abel_map_insert`.
 *        The index must be generated from the key string by the
 *        designated hashing function.
 *     2. Insert is different from action replace, 
 */
static struct abel_return_option map_insert(
    struct abel_map* ptr_map, size_t idx, char* key_str, void* ptr_data)
{
    struct abel_return_option ret;
    struct abel_key_value_pair* ptr_current_pair = NULL;
    /* current pair at given index */
    ptr_current_pair = abel_vector_at(ptr_map->ptr_pair_vector, idx).pointer;
    if (ptr_map->size == ptr_map->ptr_pair_vector->capacity) {
    /* Case 0: pair vector full, map is thus full */
        ret = abel_option_error( error_map_full() );
    } else if (ptr_current_pair == NULL) {
    /* Case 1: given index is not taken, therefore the key is new */
        /* Make a pair and emplace it in map */
        struct abel_key_value_pair* ptr_new_pair = make_pair_ptr(key_str, ptr_data);
        abel_vector_emplace(ptr_map->ptr_pair_vector, idx, ptr_new_pair);
        ptr_map->size++;
        ret = abel_option_okay(ptr_new_pair);
    } else {
    /* Case 2: Index on vector has already been occupied */
        if (strcmp(ptr_current_pair->key, key_str) == 0) {
            /* Scenario 1: Existing key is identical to the given one,
               then returns an error KEY_EXISTS. Insert is not replacement.
            */
            ret = abel_option_error( error_key_exists() );
        } else {
            /* Scenario 2: No identical key in pair vector, which means
               two key strings are converted into the same index. Collision!
               Now, we must resolve collision.
            */
            ret = resolve_collision(ptr_map, ptr_map->ptr_coll_vector, idx,
                                    key_str, ptr_data);
        }
    }
    return ret;
}

struct abel_return_option abel_map_insert(
    struct abel_map* ptr_map, char* key_str, void* ptr_data)
{
    size_t idx = key_string_to_index(key_str);
    return map_insert(ptr_map, idx, key_str, ptr_data);
}

/**
 * @brief Struct - Node found on linked list
 * 
 * This struct is used exclusively as a the return type
 * by the following static key-based searching functions
 * for linked list.
 * 
 * Fields
 * 
 * is_found : A Bool type. Set to `true` if the node satisfies
 *            the given criterion; set to `false` if not found.
 * 
 * node_index : Index of the found node on the original linked
 *              list. It is set to a negative number if node is
 *              not found.
 * 
 * ptr_node : Pointer to the found node. If the node is found,
 *            this pointer is not NULL; otherwise NULL.
 */
struct node_found {
    Bool is_found;
    int node_index;
    void* ptr_node;
};

/**
 * @brief Static - Find a node on linked list by key
 * 
 * This function is used to search along a linked list to
 * find a node that is connected to a pair object with the
 * given key.
 * 
 * Seaching for a key in a dict often requires searching the
 * linked list that is used to register key collision. Each
 * node on this linked list is connect to a pair object.
 * 
 * @param ptr_head : Pointer to the head node of the linked
 *                   list.
 * @param key_str : The key to be searched along the pairs
 *                  objects connected to the linked list nodes.
 * @return A `node_found` instance.
 *         - If key exists on the linked list, flag `is_found`
 *           is true, the index of the connected node is stored
 *           in `node_index`, and the pointer to the node is
 *           stored in field `ptr_node`.
 *         - If not, flag `is_found` is `false`, `node_index` is
 *           a negative integer, and `ptr_node` is empty.
 */
static struct node_found linked_list_find_node(
    struct abel_linked_list* ptr_head, char* key_str)
{
    struct node_found ret;
    Bool key_found = false;
    int counter = 0;
    struct abel_linked_list* ptr_current_node = ptr_head;
    while (ptr_current_node != NULL) {
        struct abel_key_value_pair* ptr_current_pair = ptr_current_node->ptr_data;
        if (strcmp(ptr_current_pair->key, key_str) == 0) {
            //ret = abel_option_okay(ptr_current_pair);
            key_found = true;
            ret.is_found = true;
            ret.ptr_node = ptr_current_node;
            ret.node_index = counter;
            break;
        }
        counter += 1;
        ptr_current_node = ptr_current_node->next;    /* move to next */
    }
    if (key_found == false) {
        //ret = abel_option_error( error_key_not_found() );
        ret.is_found = false;
        ret.ptr_node = NULL;
        ret.node_index = -99;
    }
    return ret;
}

/**
 * @brief Static - Find a pair on linked list by key
 * 
 * This function first calls `_find_node` to find the node
 * that has the matching key and then access the pair object
 * connected to the node.
 * 
 * @param ptr_head : Pointer to the head node of the linked
 *                   list.
 * @param key_str : The key to be searched along the linked
 *                  list.
 * @return Option instance.
 *         - If key exists (on linked list), flag is_okay is
 *           true and the pointer to the pair is stored in
 *           option.
 *         - If not, flag is_error is true and error
 *           KEY_NOT_FOUND is stored in option.
 */
static struct abel_return_option linked_list_find_pair(
    struct abel_linked_list* ptr_head, char* key_str)
{
    struct abel_return_option ret;
    struct abel_key_value_pair* ptr_pair = NULL;
    struct node_found node = linked_list_find_node(ptr_head, key_str);
    if (node.is_found == true) {
        ptr_pair = ( (struct abel_linked_list*)node.ptr_node )->ptr_data;
        ret = abel_option_okay(ptr_pair);
    } else {
        ret = abel_option_error( error_key_not_found() );
    }
    return ret;
}

struct abel_return_option abel_map_find(struct abel_map* ptr_map, char* key_str)
{
    struct abel_return_option ret;
    size_t idx = key_string_to_index(key_str);
    Bool key_found = false;
    if (ptr_map->ptr_pair_vector->ptr_array[idx] != NULL) {
    /* Case 0: Index is occupied */
        struct abel_key_value_pair* ptr_this_pair = ptr_map->ptr_pair_vector->ptr_array[idx];
        if (strcmp(ptr_this_pair->key, key_str) == 0) {
        /* key exists in pair vector */
            key_found = true;
            ret = abel_option_okay(ptr_this_pair);
            return ret;
        } else {
        /* key may exist on collision vector */
            if (ptr_map->ptr_coll_vector->ptr_array[idx] != NULL) {
            /* given index on collision vector is occupied */
                ret = linked_list_find_pair(
                        ptr_map->ptr_coll_vector->ptr_array[idx], key_str);
                return ret;
            } else {
            /* no collision has been registered */
                ret = abel_option_error(error_key_not_found());
                return ret;
            }
        }
    } else {
    /* Case 1: Index is not occupied, definitely not found */
        ret = abel_option_error(error_key_not_found());
        return ret;
    }
}

struct abel_return_option abel_map_at(struct abel_map* ptr_map, char* key_str)
{
    struct abel_return_option ret;
    ret = abel_map_find(ptr_map, key_str);
    if (ret.is_okay == true) {
        ret.pointer = ( (struct abel_key_value_pair*)ret.pointer )->ptr_data;
    }
    return ret;
}

struct abel_return_option abel_map_assign(
    struct abel_map* ptr_map, char* key_str, void* ptr_data)
{
    struct abel_return_option ret;
    ret = abel_map_find(ptr_map, key_str);    /* returns pair */
    if (ret.is_okay == true) {
        struct abel_key_value_pair* ptr_pair = (struct abel_key_value_pair*)ret.pointer;
        ptr_pair->ptr_data = ptr_data;
    } else {
        ret = abel_option_error( error_key_not_found() );
    }
    return ret;
}

struct abel_return_option abel_map_erase(struct abel_map* ptr_map, char* key_str)
{
    struct abel_return_option ret;
    size_t idx = key_string_to_index(key_str);
    Bool key_found = false;
    struct node_found node;
    struct abel_key_value_pair* ptr_target_pair = abel_vector_at(ptr_map->ptr_pair_vector, idx).pointer;
    if (ptr_target_pair != NULL) {
    /* Case 0: Index is occupied */
        if (strcmp(ptr_target_pair->key, key_str) == 0) {
        /* Case 0.1 key exists in pair vector */
            key_found = true;
            ret = abel_option_okay(ptr_target_pair);
            /* set corresponding index on vector to empty */
            abel_vector_emplace(ptr_map->ptr_pair_vector, idx, NULL);
            /* adjust map size */
            ptr_map->size--;
            return ret;
        } else {
        /* Caes 0.2 key may exist on collision vector */
            struct abel_linked_list* ptr_head
                = abel_vector_at(ptr_map->ptr_coll_vector,idx).pointer;
            if (ptr_head != NULL) {
            /* given index on collision vector is occupied */
                node = linked_list_find_node(ptr_head, key_str);
                if (node.is_found == true) {
                    /*
                        Erase and free the returned node. Note that the node
                        found in the above is identical to the node that is
                        to be erased.
                    */
                    struct abel_return_option ret_erase
                        = abel_linked_list_erase(&ptr_head, node.node_index);
                    if (ret_erase.is_okay == true && ptr_head == NULL) {
                        /*
                            Should the ptr_head be NULL, the only node is erased.
                            In this case, the element on the collision vector
                            is set to NULL, as the connected linked list is
                            erase completely. Then, the pair attached to the
                            only node is returned.
                        */
                        abel_vector_emplace(ptr_map->ptr_coll_vector, idx, NULL);
                        ret = abel_option_okay( ((struct abel_linked_list*)node.ptr_node)->ptr_data );
                        free(ret_erase.pointer);
                    } else {
                        /*
                            Looks like the linked list has more than one node.
                            In this case, the collision vector must register
                            the new head node and return the pair from old node.
                        */
                        abel_vector_emplace(ptr_map->ptr_coll_vector, idx, ptr_head);
                        ret = abel_option_okay( ((struct abel_linked_list*)node.ptr_node)->ptr_data );
                    }
                    /* in any case, adjust map size */
                    ptr_map->size--;
                } else {
                    ret = abel_option_error( error_key_not_found() );
                }
                return ret;
            } else {
            /* no collision has been registered */
                ret = abel_option_error( error_key_not_found() );
                return ret;
            }
        }
    } else {
    /* Case 1: Index is not occupied, definitely not found */
        ret = abel_option_error( error_key_not_found() );
        return ret;
    }
    return ret;
}